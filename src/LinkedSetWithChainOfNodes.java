import java.util.*;/** * A class that implements the ADT set by using a chain of linked nodes. * The set is never full. * * @author Travis Chamness * @version 6/11/2019 */public class LinkedSetWithChainOfNodes<T extends Comparable<? super T>> implements SetInterface<T>{    private Node<T> firstNode;            // Head reference to first node    public LinkedSetWithChainOfNodes()    {        //Takes no parameters, first node has no next or data        this.firstNode = null;        //TODO Project2 - LinkedSetWithChanOfNodes - Done    } // end default constructor    public void clear()    {        while(!isEmpty()){            remove();        }        //TODO Project2 - Clear - done    } // end clear    public boolean add(T newEntry)  {//            while        boolean successful = false;        if(!this.contains(newEntry) && newEntry != null){            Node<T> newNode = new Node<T>(newEntry, this.firstNode);            successful = true;            this.firstNode = newNode;        }        //TODO Project2 - add - Done        return successful; //THIS IS A STUB    } // end add    /**     * Locates a given entry within this set.     * Returns a reference to the node containing the entry, if located,     * or null otherwise.     *     * Utilized by removeElement method     */    private Node<T> getReferenceTo(T anEntry)    {        boolean same = false;        Node<T> returnNode = null;        Node currNode = this.firstNode;        while(!same && currNode != null && anEntry != null){ //think of this as your order of operations            if(currNode.data.equals(anEntry)){                same = true;                returnNode = currNode;            }            else currNode = currNode.next;        }        //TODO Project2 - getReference - done        return returnNode; //THIS IS A STUB    } // end getReferenceTo    public boolean removeElement(T anEntry)    {        boolean removed = false;        Node<T> element = getReferenceTo(anEntry); //returns either null or the node and is just a reference to that node        if(element != null){            //swap data, ditch with swapped.            element.data = this.firstNode.data;            this.firstNode = firstNode.next;            removed = true;        }        //TODO Project2 - removeElement - done        return removed; //THIS IS A STUB    } // end remove    public T remove()    {        T result = null;        if(this.firstNode != null){            result = this.firstNode.data;            this.firstNode = this.firstNode.next;        }        //TODO Project2 - Remove - done        return result; //THIS IS A STUB    } // end remove    public boolean contains(T anEntry)    {        //TODO Project2 - Contains - done        return getReferenceTo(anEntry) != null; //THIS IS A STUB    } // end contains    public boolean isEmpty()    {        //TODO Project2 - isEmpty - done        return this.firstNode == null; //THIS IS A STUB    } // end getLength    public T[] toArray()    {        //Get size        int counter = 0;        Node<T> currentNode = this.firstNode;        while(currentNode != null){            counter++;            currentNode = currentNode.next;        }        T[] array = (T[]) new Comparable<?>[counter];        int index = 0;        currentNode = this.firstNode;        while(index < array.length && currentNode != null){            array[index] = currentNode.data;            currentNode = currentNode.next;            index++;        }        //TODO Project2 - toArray - done        return array; //THIS IS A STUB    } // end toArray    // ****** IMPLEMENT THE FOLLOWING METHODS NOT DEFINED IN THE SetInterface ********    /**     * Displays all elements in the set;     * if the set is empty displays appropriate message     * if the set is not empty displays the elements and the number of elements     */    public void displaySet()    {        // TODO Project2 - Display set - done of O(n)        if(this.firstNode != null) {            T[] array = this.toArray(); //toArray returns array of size index which represents the length of the list            System.out.printf("The set contains the following element(s): %s - the number of elements is %d\n",Arrays.toString(array), array.length);        } else{            System.out.println("This set is empty");        }    } // end displaySet    /**     * Checks if the given set called other is the same as the set     *     * @param o the other set to be compared with     * @return true both sets are the same     */    /**     *Creat boolean same val that = true     * if otherset entries #  = this sets entries #     *  if this current node data = that current node data && same = true     *      then this current node = next and that current node = next     *  else same is false     *return same     */    public boolean equals(Object o)    {        boolean same;        if(this == o)            same = true;        else if(o == null || getClass() != o.getClass())            same = false;        else{            LinkedSetWithChainOfNodes<T> otherChain = (LinkedSetWithChainOfNodes<T>)(o);            Node<T> currNode = this.firstNode;            Node<T> otherNode = otherChain.firstNode;            same = true; //tests sameness and sets same to boolean result            while(currNode != null && otherNode != null && same){                if(!currNode.data.equals(otherNode.data)) {                    same = false;                    }                currNode = currNode.next;                otherNode = otherNode.next;            }            if(same) {                if (currNode != null || otherNode == null) {                    same = false;                }            }        }        // TODO Project2 - Equals - Done        // one return statement per value returning method please        return same; // THIS IS A STUB    }    /**     * Gets the largest value in this set.     *     * @returns a reference to the largest object, or null if the set is empty     */    /**     *MyPsuedo     * Create holding value to save greatest data value, set to first node     * While currnode != null     *  test value held against currNode data.     *  if currnode data > hold value, update value     * return held value     */    public T getMax()    {        T greatestValue = null; //the greatest value is set to null        Node<T> currentValue = this.firstNode; //current val is enstantiated to this.firstNode        if(currentValue != null) { //if there is at least one element            greatestValue = currentValue.data; //we will update greatest value to the element that exists            currentValue = currentValue.next; //Increment the currentValue            while (currentValue != null) { //and while there is another element present              if (greatestValue.compareTo(currentValue.data) < 0) { //if the other element is greater than our greatestValue                  greatestValue = currentValue.data; //set greatestValue to currentValue.data                  currentValue = currentValue.next; //point with current value to next possible value to inspect                  //repeat untill current value is null              }else currentValue = currentValue.next;            }        }        // TODO Project2 - getMax - Done        // one return statement per value returning method please        return greatestValue; // Return the greatest values data    } // end getMax    /**     * Removes and returns the smallest element in the set     *     * @return - null if the element was not found or the smallest element     */    /*     * MyPsuedo     *hold minvalue set to data of first node     * iterate through list and at each node     *   is the hold value less than currNode data?     *   if not, update, update the hold value to currNode data     * */    public T removeMin()    {        T minValue = null; //set minValue to null        Node<T> currentValue = this.firstNode; // currentValue to this.firstNode        Node<T> smallestValue = this.firstNode;        if(this.firstNode != null) {            while (currentValue != null) { //while the current value is not a null pointer                if (currentValue.data.compareTo(smallestValue.data) < 0) { //if the current val data is less than min value                    smallestValue = currentValue; //update minValue to currentValue data                    currentValue = currentValue.next; //increment currentValue                } else currentValue = currentValue.next; //otherwise increment currentValue                //Repeat process until currentValue is null            }            minValue = smallestValue.data;            removeElement(smallestValue.data);        }        // TODO Project2 - removeMin - Done        // one return statement per value returning method please        // the method must traverse the data with a while loop to find the smallest element        // outside the loop should replace the found entry with the entry located in the firstNode and call remove()        return minValue; //THIS IS A STUB    }    /**     * Removes from this set all entries that are larger than a given entry.     *     * @param anEntry the entry to be removed     */    /*     * sets a node prev to null     * sets a node curr to firstNode     * if T is null, throw an exception(maybe)     *   at each element, compare currnode to T     *       if curr > T     *           prev.next = curr.next     *           curr = prev.next     *     * */    public void removeAllLarger(T anEntry)    {        Node<T> previousNode = null; //The backup node will not        Node<T> currentNode = this.firstNode;        //checks to see if this is a valid set to run        if(anEntry != null && this.firstNode != null){            while(this.firstNode != null && this.firstNode.data.compareTo(anEntry) > 0){//while the firstnode is greater than an entry, replace                this.firstNode = this.firstNode.next;                currentNode = this.firstNode;            } //if this while loop exits, then either we have reached null or firstnode is no longer larger than an entry            if (currentNode != null){ //check if current node is not null                previousNode = currentNode; //if not, it has already been checked by previous while loop                currentNode = currentNode.next; //Press current node forward and set previous value                while(currentNode != null){                    if(currentNode.data.compareTo(anEntry) > 0){                        previousNode.next = currentNode.next;                        currentNode = previousNode.next;                    }else{                        previousNode = currentNode;                        currentNode = currentNode.next;                    }                }            }        }        // TODO Project2 - removeAllLarger - Done        // For efficiency it traverses the data and removes entries by changing pointers as needed        //     without calling any other method    } // end removeAllLarger    /**     * Creates a new set that combines the contents of this set and a     * second given set without affecting the original two sets.     *     * @param otherSet the given set     * @return a set that is the union of the two sets     */    /*     * Iterate through this set and add method to union set the data     *     *Iterate though other set     *   if compareTo other data != 0     *       then add to union set     *     * return union set     * */    public LinkedSetWithChainOfNodes<T> union(LinkedSetWithChainOfNodes<T> otherSet)    {        LinkedSetWithChainOfNodes<T> unionSet = new LinkedSetWithChainOfNodes<>();        Node<T> otherCurrent = otherSet.firstNode;        Node<T> thisCurrent = this.firstNode;        if(!this.checkIfLoopExists()) {            while (thisCurrent != null) {                unionSet.add(thisCurrent.data);                thisCurrent = thisCurrent.next;            }        }        if(!otherSet.checkIfLoopExists()) {            while (otherCurrent != null) {                unionSet.add(otherCurrent.data);                otherCurrent = otherCurrent.next;            }        }        // TODO Project2 - Union - Needs work, running in an endless loop        // one return statement per value returning method please        return unionSet;    } // end union    /**     * Creates a new set that contains those objects that occur in both this     * set and a second given set without affecting the original two sets.     *     * @param otherSet the given set     * @return a set that is the intersection of the two sets     */    /*     * Iterate through this list     *   at each curr, thatList.getRef...(curr.data)     *       if this returns !null     *           then add to intersection list     * return intersection list     * */    public LinkedSetWithChainOfNodes<T> intersection(LinkedSetWithChainOfNodes<T> otherSet)    {        LinkedSetWithChainOfNodes<T> intersectionSet = new LinkedSetWithChainOfNodes<>();        Node<T> otherCurrent = otherSet.firstNode;        while(otherCurrent != null){            if(this.getReferenceTo(otherCurrent.data) != null){                intersectionSet.add(otherCurrent.data);                otherCurrent = otherCurrent.next;            }else otherCurrent = otherCurrent.next;        }        // TODO Project2 - Intersection - Done        // one return statement per value returning method please        // call getReferenceTo(anElement) instead of contains        return intersectionSet;    } // end intersection    /**     * Creates a new set of objects that would be left in this set     * after removing those that also occur in a second given set     * without affecting the original two sets.     *     * @param otherSet the given set     * @return a set that is the difference of the two sets     */    /*     *iterate through this set list and add data to diffSet     * iterate over diffSet and compare to other set     *   if compareTo == 0     *       removeElement(element)     * return diffSet     * */    public LinkedSetWithChainOfNodes<T> difference(LinkedSetWithChainOfNodes<T> otherSet)    {        LinkedSetWithChainOfNodes<T> differenceSet = new LinkedSetWithChainOfNodes<>();        Node<T> otherCurrent = otherSet.firstNode;        while(otherCurrent != null){            if(this.getReferenceTo(otherCurrent.data) == null){                differenceSet.add(otherCurrent.data);                otherCurrent = otherCurrent.next;            } else otherCurrent = otherCurrent.next;        }        // TODO Project2 - Difference        // one return statement per value returning method please        // do not call contains, call removeElement(anElement) instead        return differenceSet;    } // end difference    /*     * initialize hold node, curr node, and prev node     * loop through list until reach curr = null     * set prev.next to firstNode.next     * then set firstnode.next to prev.next     * then set prev.next to null     * */    public void moveFirstToEnd()    {        Node<T> currentNode = this.firstNode;        Node<T> holdFirst = this.firstNode;        if(this.firstNode != null && this.firstNode.next != null){ //tests if there are at least two nodes            while(currentNode.next != null){                currentNode = currentNode.next; //loop iterates over list until it reaches the last node            }            this.firstNode = holdFirst.next;            currentNode.next = holdFirst; //where currentNode.next = null, set it to firstNode            holdFirst.next = null;        }        //TODO Project2 - moveFirstToEnd - Done        // this method should run only if the chain has at least two node        // do not create a new Node object (i.e. new Node<>()), just utilize        // reference variables (i.e. Node<T> someNode) to change appropriate pointers        // DOES NOT rely on the number of elements    } // end moveToEnd    /**     * Replaces the first entry in this set with a given object.     *     * @param replacement the given object     * @return the original entry in the set that was replaced or     *         null if empty chain or a duplicate     */    /*     * Initialize replaced to first.next.data     * if first.next is not null     *   first.next.data equals replacement     * elsewise add replacement     * return replaced     * */    public T replace(T replacement)    {        T replacedValue = null; //initialize the replacedValue to null        if(this.firstNode != null && !this.contains(replacement)){ //if the firstnode is not null AND this container has no entries of replacement            replacedValue = this.firstNode.data; //then copy the value we will replace            this.firstNode.data = replacement; //and replace that copy with the replacement value        }        //TODO Project2 - Replace -Done        // change the data at the first node if appropriate        return replacedValue;    } // end replace    /**     * This method find the data in the middle node in one pass     *     * @return returns tha data in the middle node     */    /*     *Initialize a fast node and a slow node to firstNode     * increment toEnd node by 2 and toMiddle node by 1 while toEnd does not equal null     * return toMiddle node data     * */    public T findMiddleElementInOnePass()    {        T value = null;        Node<T> slow = this.firstNode;        Node<T> fast = this.firstNode;        if(fast != null) { //can condense if statement into while, but will need to find new place to update value outside loop            while (fast.next != null) { //empty set makes null pointer exception                fast = fast.next;                if (fast.next != null) {                    slow = slow.next;                    fast = fast.next;                }            }            value = slow.data;        }        // TODO Project2 - findMiddleElementInOnePass - done - is this inneficient enough?        // uses two pointers - DOES NOT rely on the number of elements        return value; // THIS IS A STUB    }    /**     * Check if the linked list has loop in one pass     *     * @return returns true as soon as the first loop is found     */    /*     * initialize two nodes both pointing at firstNode. (spd1 and spd2)     * spd1 traverses the chain incrementing one element per cycle     * spd2 traverses the chain incrementing two elements per cycle     * each cycle compares the two elements seeing if at any point they are the same or that spd2 is null     *     * */    public boolean checkIfLoopExists()    {        boolean loop = false;        Node<T> slow = this.firstNode;        Node<T> fast = this.firstNode;        while(fast != null && fast.next != null && !loop){ //checks first node where I am to be null then checks the next node            fast = fast.next; //Increments fast by first node in loop            if(fast.next != null){ //tests fast.next                fast = fast.next; //increments fast by second node in loop                slow = slow.next; //increments slow by first node in loop                if(slow == fast){ //tests if slow and fast are on the same node. Appropriate use of '==' in this case.                    loop = true; //if slow and fast are on the same node, then a loop exists                    //loop value will break while loop and return that a loop exists is true                }            }        }        // TODO Project2 - checkIfLoopExists - done        // uses two pointers - DOES NOT rely on the number of elements        return loop; // THIS IS A STUB    }    /**     * This method is created to test loop detection     */    private void createALoop()    {        // starting with a chain: A-> B-> C-> D-> E-> F-> G-> H-> I-> null        Node<T> last = this.firstNode;        while (last.next != null)            last = last.next;        last.next = this.firstNode.next.next.next;        // hardcoded a loop in the chain: A-> B-> C-> D-> E-> F-> G-> H-> I-> D    }    // A class of nodes for a chain of linked nodes.    private class Node<S>    {        private S data; // Data portion        private Node next; // Link to next node        private Node(S dataPortion)        {            this(dataPortion, null);        } // end constructor        private Node(S dataPortion, Node nextNode)        {            this.data = dataPortion;            this.next = nextNode;        } // end constructor    } // end Node    public static void main(String[] args)    {        String[] inputData = {"A", "B", "C", "D", "A", "C", "B", "B"};        System.out.println("\n\u001B[35m\u001B[1mRUNNING TEST CASES FOR METHODS DEFINED IN SetInterface plus displaySet\u001B[0m");        System.out.println("--> Creating aSet and adding to it elements from inputData: " + Arrays.toString(inputData));        SetInterface<String> aSet = new LinkedSetWithChainOfNodes<>();        for (int i=0; i < inputData.length; i++)        {            aSet.add(inputData[i]);        }        aSet.displaySet();        System.out.println("\n--> Clearing aSet");        aSet.clear();        aSet.displaySet();        System.out.println("--> aSet isEmpty returns: " + aSet.isEmpty());        System.out.println("\n--> Creating set1 and set2");        SetInterface<String> set1 = new LinkedSetWithChainOfNodes<>();        SetInterface<String> set2 = new LinkedSetWithChainOfNodes<>();        System.out.println("\n--> Adding elements to set1");        set1.add("A");        set1.add("A");        set1.add("B");        set1.add("A");        set1.add("C");        set1.add("Z");        set1.add("A");        System.out.println("--> set1 after adding elements");        set1.displaySet();        System.out.println("\n--> Adding elements to set2");        set2.add("A");        set2.add("B");        set2.add("B");        set2.add("A");        set2.add("C");        set2.add("C");        set2.add("Z");        set2.add("D");        System.out.println("--> set2 after adding elements");        set2.displaySet();        System.out.println("\n--> set1 contains \"A\": " + set1.contains("A"));        System.out.println("--> set1 contains \"E\": " + set1.contains("E"));        System.out.println("\n--> Removing \"B\" from set1");        set1.removeElement("B");        System.out.println("--> After removing \"B\" from set1, ");        set1.displaySet();        System.out.println("\n--> Removing random element from set1");        String removed = set1.remove();        System.out.println("--> set1.remove() returned: \"" + removed + "\"");        set1.displaySet();        System.out.println("\n--> Removing \"A\" from set1");        set1.removeElement("A");        System.out.println("--> After removing \"A\" from set1, ");        set1.displaySet();        System.out.println("\n--> Removing random element from set1");        removed = set1.remove();        System.out.println("--> set1.remove() returned: \"" + removed + "\"");        set1.displaySet();        System.out.println("\n--> Adding 4 elements to set1");        set1.add("K");        set1.add("L");        set1.add("M");        set1.add("N");        System.out.println("--> After adding 4 elements to set1:");        set1.displaySet();        System.out.println("\n--> Trying to add duplicate element \"N\" to set1");        set1.add("N");        System.out.println("--> After adding a duplicate element \"N\" to set1");        set1.displaySet();        System.out.println("\nTrying to add null entry");        String nullEntry = null;        set1.add(nullEntry);        System.out.println("--> set1 after adding:");        set1.displaySet();        System.out.println("\n\u001B[35m\u001B[1mRUNNING TEST CASES FOR METHODS NOT DEFINED IN SetInterface\u001B[0m");        LinkedSetWithChainOfNodes<String> set3 = new LinkedSetWithChainOfNodes<>();        LinkedSetWithChainOfNodes<String> set3Plus1 = new LinkedSetWithChainOfNodes<>();        LinkedSetWithChainOfNodes<String> set4 = new LinkedSetWithChainOfNodes<>();        LinkedSetWithChainOfNodes<String> set5 = new LinkedSetWithChainOfNodes<>();        LinkedSetWithChainOfNodes<String> testSet = new LinkedSetWithChainOfNodes<>();        LinkedSetWithChainOfNodes<String> emptySet = new LinkedSetWithChainOfNodes<>();        LinkedSetWithChainOfNodes<String> setCopyOfSet3 = new LinkedSetWithChainOfNodes<>();        set3Plus1.add("Z");        set3.add("C");        set3Plus1.add("C");        setCopyOfSet3.add("C");        set3.add("B");        set3Plus1.add("B");        setCopyOfSet3.add("B");        set3.add("D");        set3Plus1.add("D");        setCopyOfSet3.add("D");        set3.add("A");        set3Plus1.add("A");        setCopyOfSet3.add("A");        set3.add("X");        set3Plus1.add("X");        setCopyOfSet3.add("X");        // testing equals        System.out.println("\n\u001B[35m\u001B[1m***Testing equals method***\u001B[0m");        System.out.println("set3:");        set3.displaySet();        System.out.println("Are set3 and emptySet equal? --> " + (set3.equals(emptySet) ? "YES" : "NO"));        System.out.println("Are emptySet and emptySet equal? --> " + (emptySet.equals(emptySet) ? "YES" : "NO"));        System.out.println("Are emptySet and set3 equal? --> " + (emptySet.equals(set3) ? "YES" : "NO"));        set4.add("A");        set4.add("B");        set4.add("D");        set4.add("C");        set4.add("X");        set4.add("Z");        System.out.println("\nset4:");        set4.displaySet();        System.out.println("Are set3 and set4 equal? --> " + (set3.equals(set4) ? "YES" : "NO"));        System.out.println("\nRemoved \"" + set4.remove() + "\" from set4.");        set4.displaySet();        System.out.println("Are set3 and set4 equal now? --> " + (set3.equals(set4) ? "YES" : "NO"));        System.out.println("\nsetCopyOfSet3:");        setCopyOfSet3.displaySet();        System.out.println("Are set3 and setCopyOfSet3 equal? --> " + (set3.equals(setCopyOfSet3) ? "YES" : "NO"));        System.out.println("\nset3Plus1:");        set3Plus1.displaySet();        System.out.println("Are set3 and set3Plus1 equal? --> " + (set3.equals(set3Plus1) ? "YES" : "NO"));        // testing getMax        System.out.println("\n\u001B[35m\u001B[1m***Testing getMax method***\u001B[0m");        System.out.println("The largest item in emptySet is: " + emptySet.getMax());        set3.clear();        set3.add("D");        set3.add("X");        set3.add("A");        set3.add("C");        System.out.println("\nset3: ");        set3.displaySet();        System.out.println("The largest item in set3 is: " + set3.getMax());        set4.clear();        set4.add("B");        set4.add("A");        set4.add("C");        set4.add("Z");        System.out.println("\nset4: ");        set4.displaySet();        System.out.println("The largest item in set4 is: " + set4.getMax());        set5.add("Y");        set5.add("A");        set5.add("C");        set5.add("B");        System.out.println("\nset5: ");        set5.displaySet();        System.out.println("The largest item in set5 is: " + set5.getMax());        System.out.println("\n\u001B[35m\u001B[1m***Testing union, removeMin, intersection, difference and subset methods***\u001B[0m");        System.out.println("set3: ");        set3.displaySet();        System.out.println("set4: ");        set4.displaySet();        // testing union        System.out.println("\n\u001B[35m\u001B[1m***Testing union method***\u001B[0m");        LinkedSetWithChainOfNodes<String> everything = set3.union(set4);        System.out.println("The union of set3 and set4 is ");        everything.displaySet();        everything = set3.union(emptySet);        System.out.println("\nThe union of set3 and emptySet is ");        everything.displaySet();        everything = emptySet.union(set3);        System.out.println("\nThe union of emptySet and set3 is ");        everything.displaySet();        // testing removeMin        System.out.println("\n\u001B[35m\u001B[1m***Testing removeMin method***\u001B[0m");        String smallest;        // TODO - uncomment the following lines to test removeMin        while (!everything.isEmpty())        {            smallest = everything.removeMin();            System.out.println("Removed the smallest element \"" + smallest + "\" from the union set; the current content is:");            everything.displaySet();        }        smallest = everything.removeMin();        if (smallest == null)            System.out.println("\nThe union set is empty and removeMin returned null - CORRECT");        else            System.out.println("\nThe union set is empty but removeMin did not return null - INCORRECT");        // testing intersection        System.out.println("\n\u001B[35m\u001B[1m***Testing intersection method***\u001B[0m");        LinkedSetWithChainOfNodes<String> commonItems = set3.intersection(set4);        System.out.println("The intersection of set3 and set4 is ");        commonItems.displaySet();        commonItems = set3.intersection(emptySet);        System.out.println("\nThe intersection of set3 and emptySet is ");        commonItems.displaySet();        commonItems = emptySet.intersection(set3);        System.out.println("\nThe intersection of emptySet and set3 is ");        commonItems.displaySet();        // testing difference        System.out.println("\n\u001B[35m\u001B[1m***Testing difference method***\u001B[0m");        LinkedSetWithChainOfNodes<String> leftOver = set3.difference(set4);        System.out.println("The difference of set3 and set4 is ");        leftOver.displaySet();        leftOver = set4.difference(set3);        System.out.println("\nThe difference of set4 and set3 is ");        leftOver.displaySet();        leftOver = set3.difference(emptySet);        System.out.println("\nThe difference of set3 and emptySet is ");        leftOver.displaySet();        leftOver = emptySet.difference(set3);        System.out.println("\nThe difference of emptySet and set3 is ");        leftOver.displaySet();        // testing replace        System.out.println("\n\u001B[35m\u001B[1m***Testing replace method***\u001B[0m");        set3.clear();        set3.add("A");        set3.add("C");        set3.add("D");        set3.add("X");        set3.add("B");        set3.add("A");        set3.add("X");        System.out.println("set3:");        set3.displaySet();        System.out.println("Trying to replace the first element with \"X\"");        if (set3.replace("X") == null)            System.out.println("CORRECT - returned null since no replacement was made");        else            System.out.println("INCORRECT - replacement should not be made");        System.out.println("Now set3 contains:");        set3.displaySet();        System.out.println("Trying to replace the first element with \"B\"");        if (set3.replace("B") == null)            System.out.println("CORRECT - returned null since no replacement was made");        else            System.out.println("INCORRECT - replacement should not be made");        System.out.println("Now set3 contains:");        set3.displaySet();        System.out.println("Trying to replace the first element with \"Z\"");        if (set3.replace("Z") == null)            System.out.println("INCORRECT - replacement should be made");        else            System.out.println("CORRECT - replacement was made");        System.out.println("Now set3 contains:");        set3.displaySet();        System.out.println("\nCalling replace on emptySet");        String replaced = emptySet.replace("X");        if (replaced == null)            System.out.println("The set is empty and replace returned null - CORRECT");        else            System.out.println("The set is empty but replace did not return null - INCORRECT");        System.out.println("Now emptySet contains:");        emptySet.displaySet();        // testing removeAllLarger        System.out.println("\n\u001B[35m\u001B[1m***Testing removeAllLarger method***\u001B[0m");        System.out.println("set3:");        set3.displaySet();        System.out.println("Removing all that are larger than \"Z\"");        set3.removeAllLarger("Z");        System.out.println("After removing all that are larger than \"Z\" set3 contains:");        set3.displaySet();        System.out.println("Removing all that are larger than \"D\"");        set3.removeAllLarger("D");        System.out.println("After removing all that are larger than \"D\" set3 contains:");        set3.displaySet();        System.out.println("Removing all that are larger than \"B\"");        set3.removeAllLarger("B");        System.out.println("After removing all that are larger than \"B\" set3 contains:");        set3.displaySet();        System.out.println("\n\u001B[35m\u001B[1m*** TESTING moveFirstToEnd ***\u001B[0m");        testSet.clear();        testSet.add("C");        testSet.add("B");        testSet.add("A");        System.out.println("List before:");        testSet.displaySet();        testSet.moveFirstToEnd();        System.out.println("List after:");        testSet.displaySet();        System.out.println();        System.out.println("Calling moveFirstToEnd three times");        testSet.clear();        testSet.add("B");        testSet.add("C");        testSet.add("A");        System.out.println("List before:");        testSet.displaySet();        testSet.moveFirstToEnd();        testSet.moveFirstToEnd();        testSet.moveFirstToEnd();        System.out.println("List after:");        testSet.displaySet();        System.out.println();        System.out.println("Calling moveFirstToEnd on a list of length 0");        testSet.clear();        System.out.println("List before:");        testSet.displaySet();        testSet.moveFirstToEnd();        System.out.println("List after:");        testSet.displaySet();        System.out.println();        System.out.println("Calling moveFirstToEnd on a list of length 1");        testSet.clear();        testSet.add("B");        System.out.println("List before:");        testSet.displaySet();        testSet.moveFirstToEnd();        System.out.println("List after:");        testSet.displaySet();        System.out.println();        System.out.println("Calling moveFirstToEnd on a list of length 2");        testSet.clear();        testSet.add("A");        testSet.add("B");        System.out.println("List before:");        testSet.displaySet();        testSet.moveFirstToEnd();        System.out.println("List after:");        testSet.displaySet();        System.out.println();        System.out.println("\n\u001B[35m\u001B[1m*** TESTING findMiddleElementInOnePass ***\u001B[0m");        testSet.clear();        testSet.displaySet();        System.out.println("middle: " + testSet.findMiddleElementInOnePass());        testSet.add("A");        testSet.displaySet();        System.out.println("middle: " + testSet.findMiddleElementInOnePass() + "\n");        testSet.add("B");        testSet.displaySet();        System.out.println("middle: " + testSet.findMiddleElementInOnePass() + "\n");        testSet.add("C");        testSet.add("D");        testSet.add("E");        testSet.add("F");        testSet.displaySet();        System.out.println("middle: " + testSet.findMiddleElementInOnePass() + "\n");        testSet.add("G");        testSet.displaySet();        System.out.println("middle: " + testSet.findMiddleElementInOnePass() + "\n");        System.out.println("\n\u001B[35m\u001B[1m*** TESTING checkIfLoopExists ***\u001B[0m");        boolean result = testSet.checkIfLoopExists();        if (!result)            System.out.println("testSet does not have a loop - CORRECT");        else            System.out.println("testSet does have a loop - INCORRECT");        LinkedSetWithChainOfNodes<String> setWithLoop = new LinkedSetWithChainOfNodes<>();        setWithLoop.add("I");        setWithLoop.add("H");        setWithLoop.add("G");        setWithLoop.add("F");        setWithLoop.add("E");        setWithLoop.add("D");        setWithLoop.add("C");        setWithLoop.add("B");        setWithLoop.add("A");        setWithLoop.createALoop();        result = setWithLoop.checkIfLoopExists();        if (result)            System.out.println("setWithLoop does have a loop - CORRECT");        else            System.out.println("setWithLoop does not have a loop - INCORRECT");    } // end main} // end LinkedSetWithChainOfNodes